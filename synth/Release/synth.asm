; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27025.1 

	TITLE	D:\dev\raw4k\synth\synth.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_runSynth@4
PUBLIC	__real@00000000
PUBLIC	__real@37be37c6
PUBLIC	__real@3daaaaab
PUBLIC	__real@3e000000
PUBLIC	__real@3e800000
PUBLIC	__real@3ea8f5c3
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f266666
PUBLIC	__real@3f800000
PUBLIC	__real@3fa2f983
PUBLIC	__real@40000000
PUBLIC	__real@402e147b
PUBLIC	__real@40400000
PUBLIC	__real@40700000
PUBLIC	__real@40800000
PUBLIC	__real@40833333
PUBLIC	__real@40c90fdb
PUBLIC	__real@40c9999a
PUBLIC	__real@40e55dd180000000
PUBLIC	__real@41000000
PUBLIC	__real@41400000
PUBLIC	__real@41490fdb
PUBLIC	__real@414fd639
PUBLIC	__real@42000000
PUBLIC	__real@435c0000
PUBLIC	__real@43c80000
PUBLIC	__real@469c4000
PUBLIC	__real@46fffe00
PUBLIC	__real@bf800000
PUBLIC	__real@c1200000
PUBLIC	__real@c1f00000
EXTRN	__fltused:DWORD
;	COMDAT __real@c1f00000
CONST	SEGMENT
__real@c1f00000 DD 0c1f00000r			; -30
CONST	ENDS
;	COMDAT __real@c1200000
CONST	SEGMENT
__real@c1200000 DD 0c1200000r			; -10
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@469c4000
CONST	SEGMENT
__real@469c4000 DD 0469c4000r			; 20000
CONST	ENDS
;	COMDAT __real@43c80000
CONST	SEGMENT
__real@43c80000 DD 043c80000r			; 400
CONST	ENDS
;	COMDAT __real@435c0000
CONST	SEGMENT
__real@435c0000 DD 0435c0000r			; 220
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@414fd639
CONST	SEGMENT
__real@414fd639 DD 0414fd639r			; 12.9898
CONST	ENDS
;	COMDAT __real@41490fdb
CONST	SEGMENT
__real@41490fdb DD 041490fdbr			; 12.5664
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40e55dd180000000
CONST	SEGMENT
__real@40e55dd180000000 DQ 040e55dd180000000r	; 43758.5
CONST	ENDS
;	COMDAT __real@40c9999a
CONST	SEGMENT
__real@40c9999a DD 040c9999ar			; 6.3
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40833333
CONST	SEGMENT
__real@40833333 DD 040833333r			; 4.1
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40700000
CONST	SEGMENT
__real@40700000 DD 040700000r			; 3.75
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@402e147b
CONST	SEGMENT
__real@402e147b DD 0402e147br			; 2.72
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fa2f983
CONST	SEGMENT
__real@3fa2f983 DD 03fa2f983r			; 1.27324
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f266666
CONST	SEGMENT
__real@3f266666 DD 03f266666r			; 0.65
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3ea8f5c3
CONST	SEGMENT
__real@3ea8f5c3 DD 03ea8f5c3r			; 0.33
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e000000
CONST	SEGMENT
__real@3e000000 DD 03e000000r			; 0.125
CONST	ENDS
;	COMDAT __real@3daaaaab
CONST	SEGMENT
__real@3daaaaab DD 03daaaaabr			; 0.0833333
CONST	ENDS
;	COMDAT __real@37be37c6
CONST	SEGMENT
__real@37be37c6 DD 037be37c6r			; 2.26757e-05
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
; Function compile flags: /Ogsp
; File d:\dev\raw4k\synth\synth.c
;	COMDAT _getSound
_TEXT	SEGMENT
tv259 = -44						; size = 8
_sineRamp$1$ = -36					; size = 4
_sqrRamp$1$ = -32					; size = 4
$T1 = -28						; size = 4
tv290 = -24						; size = 4
tv266 = -24						; size = 4
_tmp$2 = -20						; size = 4
_tmp$3 = -16						; size = 4
_padF$1$ = -12						; size = 4
_x$4 = -12						; size = 4
_time$1$ = -8						; size = 4
_i$5 = -8						; size = 4
_x$6 = -8						; size = 4
_x$7 = -8						; size = 4
_tmp$8 = -8						; size = 4
_t$1$ = -4						; size = 4
_time$ = 8						; size = 4
_getSound PROC						; COMDAT

; 137  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 69   :     return a - b * floor_( a / b );

	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR __real@3e800000

; 41   :     return f2i( x - 0.5f );

	fsub	DWORD PTR __real@3f000000
	fstp	DWORD PTR _x$4[ebp]

; 138  :     float t = mod( time, 4. );

	fld	DWORD PTR _x$4[ebp]
	fistp	DWORD PTR _tmp$8[ebp]

; 41   :     return f2i( x - 0.5f );

	fild	DWORD PTR _tmp$8[ebp]

; 139  :     
; 140  :     float sineRamp = clamp((time - 4.0f) / 12.0f, 0.0f, 1.0f);

	sub	esp, 12					; 0000000cH

; 69   :     return a - b * floor_( a / b );

	fld	DWORD PTR __real@40800000
	fmul	ST(1), ST(0)
	fld	DWORD PTR _time$[ebp]
	fld	ST(0)
	fsubrp	ST(3), ST(0)
	fxch	ST(2)
	fstp	DWORD PTR _t$1$[ebp]

; 139  :     
; 140  :     float sineRamp = clamp((time - 4.0f) / 12.0f, 0.0f, 1.0f);

	fld1
	fstp	DWORD PTR [esp+8]
	fldz
	fst	QWORD PTR tv259[ebp]
	fstp	DWORD PTR [esp+4]
	fsubp	ST(1), ST(0)
	fmul	DWORD PTR __real@3daaaaab
	fstp	DWORD PTR [esp]
	call	_clamp
	fstp	DWORD PTR _sineRamp$1$[ebp]

; 141  :     float sqrRamp  = clamp((time - 8.0f) /  8.0f, 0.0f, 1.0f);

	fld1
	fstp	DWORD PTR [esp+8]
	fld	QWORD PTR tv259[ebp]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _time$[ebp]
	fsub	DWORD PTR __real@41000000
	fmul	DWORD PTR __real@3e000000
	fstp	DWORD PTR [esp]
	call	_clamp
	fstp	DWORD PTR _sqrRamp$1$[ebp]

; 142  :     
; 143  :     float padF = padFreq( time );

	fld	DWORD PTR _time$[ebp]
	add	esp, 8
	fstp	DWORD PTR [esp]
	call	_padFreq
	fstp	DWORD PTR _padF$1$[ebp]

; 127  :     return floor_( t * 2.0f ) / 2.0f;

	fld	DWORD PTR _t$1$[ebp]

; 142  :     
; 143  :     float padF = padFreq( time );

	add	esp, 4

; 127  :     return floor_( t * 2.0f ) / 2.0f;

	fld	ST(0)
	faddp	ST(1), ST(0)

; 41   :     return f2i( x - 0.5f );

	fsub	DWORD PTR __real@3f000000
	fstp	DWORD PTR _x$7[ebp]

; 144  :     
; 145  :     float signal =

	fld	DWORD PTR _x$7[ebp]
	fistp	DWORD PTR _tmp$3[ebp]

; 41   :     return f2i( x - 0.5f );

	fild	DWORD PTR _tmp$3[ebp]

; 127  :     return floor_( t * 2.0f ) / 2.0f;

	fmul	DWORD PTR __real@3f000000
	fstp	DWORD PTR $T1[ebp]

; 132  :     if (t > 3.75f) return 3.75f;

	fld	DWORD PTR __real@40700000
	fld	DWORD PTR _t$1$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN15@getSound
	fstp	ST(1)

; 41   :     return f2i( x - 0.5f );

	fstp	DWORD PTR _x$6[ebp]

; 144  :     
; 145  :     float signal =

	fld	DWORD PTR _x$6[ebp]
	fistp	DWORD PTR _tmp$2[ebp]

; 41   :     return f2i( x - 0.5f );

	fild	DWORD PTR _tmp$2[ebp]

; 133  :     return floor_( t + 0.5f ) - 0.5f;

	fsub	DWORD PTR __real@3f000000
	fld	DWORD PTR _t$1$[ebp]
$LN15@getSound:

; 144  :     
; 145  :     float signal =

	fsubrp	ST(1), ST(0)

; 108  :      return 0.33f * funcRand( 20000.0f * pow_( 2.72f, -10.0f*time )) * pow_( 2.72f, -30.0f*time );

	push	ecx
	push	ecx

; 144  :     
; 145  :     float signal =

	fst	DWORD PTR _time$1$[ebp]

; 108  :      return 0.33f * funcRand( 20000.0f * pow_( 2.72f, -10.0f*time )) * pow_( 2.72f, -30.0f*time );

	fmul	DWORD PTR __real@c1200000
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR __real@402e147b
	fstp	DWORD PTR [esp]
	call	_pow_
	fmul	DWORD PTR __real@469c4000
	add	esp, 4
	fstp	DWORD PTR [esp]
	call	_funcRand
	fmul	DWORD PTR __real@3ea8f5c3
	fstp	DWORD PTR tv290[ebp]
	fld	DWORD PTR _time$1$[ebp]
	fmul	DWORD PTR __real@c1f00000
	fstp	DWORD PTR [esp]
	fld	DWORD PTR __real@402e147b
	push	ecx
	fstp	DWORD PTR [esp]
	call	_pow_
	fmul	DWORD PTR tv290[ebp]

; 144  :     
; 145  :     float signal =

	xor	eax, eax

; 108  :      return 0.33f * funcRand( 20000.0f * pow_( 2.72f, -10.0f*time )) * pow_( 2.72f, -30.0f*time );

	add	esp, 8

; 144  :     
; 145  :     float signal =

	inc	eax
	mov	DWORD PTR _i$5[ebp], eax

; 108  :      return 0.33f * funcRand( 20000.0f * pow_( 2.72f, -10.0f*time )) * pow_( 2.72f, -30.0f*time );

	fstp	DWORD PTR tv266[ebp]
	fld	DWORD PTR _padF$1$[ebp]
	fadd	DWORD PTR __real@40000000
	fmul	DWORD PTR __real@40c90fdb

; 144  :     
; 145  :     float signal =

	fmul	DWORD PTR _time$[ebp]
	fld	DWORD PTR __real@3fa2f983
$LN27@getSound:

; 92   :         float n = (float)i;

	fild	DWORD PTR _i$5[ebp]
	add	eax, 2
	mov	DWORD PTR _i$5[ebp], eax

; 93   :         result += 4.0f / PI / n * sinf( n * x );

	fld	ST(2)
	fmul	ST(0), ST(1)
	fsin
	fld	ST(2)
	fdivrp	ST(2), ST(0)
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR tv259[ebp]
	fstp	QWORD PTR tv259[ebp]
	cmp	eax, 5
	jle	SHORT $LN27@getSound

; 70   : }
; 71   : 
; 72   : //==============================================================================
; 73   : 
; 74   : static float hash( float i )
; 75   : {
; 76   :     return fract( sinf( i * 12.9898f ) * 43758.5453f );
; 77   : }
; 78   :     
; 79   : static float funcRand( float x )
; 80   : {
; 81   :     float a = hash( floor_( x ));
; 82   :     float b = hash( floor_( x + 1.0f ));
; 83   :     return 1.0f - 2.0f * mix( a, b, smoothstep( 0.0f, 1.0f, fract( x )));
; 84   : }
; 85   : 
; 86   : static float taylorSquareWave( float x )
; 87   : {
; 88   :     float result = 0.0f;
; 89   :     
; 90   :     for( int i = 1; i <= 5; i += 2 )

	fstp	ST(1)

; 146  :         1.00f * kick( t - latestKickStartTime( t )) +
; 147  :         0.50f * hat( t - latestHatStartTime( t )) +
; 148  :         0.25f * sqrRamp * taylorSquareWave( 2.0f * PI * (padF + 2.0f) * time ) +
; 149  :         0.50f * sineRamp * sinf( 4.0f * PI * padF * time );
; 150  :     
; 151  :     return clamp( signal, -1.0f, 1.0f );

	sub	esp, 12					; 0000000cH

; 90   :     for( int i = 1; i <= 5; i += 2 )

	fstp	ST(0)

; 146  :         1.00f * kick( t - latestKickStartTime( t )) +
; 147  :         0.50f * hat( t - latestHatStartTime( t )) +
; 148  :         0.25f * sqrRamp * taylorSquareWave( 2.0f * PI * (padF + 2.0f) * time ) +
; 149  :         0.50f * sineRamp * sinf( 4.0f * PI * padF * time );
; 150  :     
; 151  :     return clamp( signal, -1.0f, 1.0f );

	fld1
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR __real@bf800000
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _t$1$[ebp]
	fsub	DWORD PTR $T1[ebp]
	fstp	DWORD PTR [esp]
	call	_kick
	fld	DWORD PTR __real@3f000000
	fld	DWORD PTR tv266[ebp]
	fmul	ST(0), ST(1)
	faddp	ST(2), ST(0)
	fld	DWORD PTR _sqrRamp$1$[ebp]
	fmul	DWORD PTR __real@3e800000
	fmul	QWORD PTR tv259[ebp]
	faddp	ST(2), ST(0)
	fld	DWORD PTR _padF$1$[ebp]
	fmul	DWORD PTR __real@41490fdb
	fmul	DWORD PTR _time$[ebp]
	fsin
	fld	DWORD PTR _sineRamp$1$[ebp]
	fmulp	ST(2), ST(0)
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR [esp]
	call	_clamp
	add	esp, 12					; 0000000cH

; 152  : }

	leave
	ret	0
_getSound ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\dev\raw4k\synth\synth.c
;	COMDAT _latestHatStartTime
_TEXT	SEGMENT
_tmp$1 = -4						; size = 4
_x$ = 8							; size = 4
_t$ = 8							; size = 4
_latestHatStartTime PROC				; COMDAT

; 131  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 132  :     if (t > 3.75f) return 3.75f;

	fld	DWORD PTR __real@40700000
	fld	DWORD PTR _t$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN9@latestHatS
	fstp	ST(0)

; 134  : }

	leave
	ret	0
$LN9@latestHatS:

; 132  :     if (t > 3.75f) return 3.75f;

	fstp	ST(1)

; 41   :     return f2i( x - 0.5f );

	fstp	DWORD PTR _x$[ebp]

; 133  :     return floor_( t + 0.5f ) - 0.5f;

	fld	DWORD PTR _x$[ebp]
	fistp	DWORD PTR _tmp$1[ebp]

; 41   :     return f2i( x - 0.5f );

	fild	DWORD PTR _tmp$1[ebp]

; 133  :     return floor_( t + 0.5f ) - 0.5f;

	fsub	DWORD PTR __real@3f000000

; 134  : }

	leave
	ret	0
_latestHatStartTime ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\dev\raw4k\synth\synth.c
;	COMDAT _latestKickStartTime
_TEXT	SEGMENT
_tmp$1 = -4						; size = 4
_x$ = 8							; size = 4
_t$ = 8							; size = 4
_latestKickStartTime PROC				; COMDAT

; 126  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 127  :     return floor_( t * 2.0f ) / 2.0f;

	fld	DWORD PTR _t$[ebp]
	fadd	ST(0), ST(0)

; 41   :     return f2i( x - 0.5f );

	fsub	DWORD PTR __real@3f000000
	fstp	DWORD PTR _x$[ebp]

; 127  :     return floor_( t * 2.0f ) / 2.0f;

	fld	DWORD PTR _x$[ebp]
	fistp	DWORD PTR _tmp$1[ebp]

; 41   :     return f2i( x - 0.5f );

	fild	DWORD PTR _tmp$1[ebp]

; 127  :     return floor_( t * 2.0f ) / 2.0f;

	fmul	DWORD PTR __real@3f000000

; 128  : }

	leave
	ret	0
_latestKickStartTime ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\dev\raw4k\synth\synth.c
;	COMDAT _padFreq
_TEXT	SEGMENT
_tmp$1 = -8						; size = 4
_x$2 = -4						; size = 4
_time$ = 8						; size = 4
_padFreq PROC						; COMDAT

; 112  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ecx

; 113  :     float detune = 0.0f;

	fldz

; 114  :     if( time < 0.0f ) {

	fld	DWORD PTR _time$[ebp]
	fcom	ST(1)
	fnstsw	ax
	fld	DWORD PTR __real@3daaaaab
	test	ah, 5
	jp	SHORT $LN16@padFreq
	fstp	ST(1)
	fstp	ST(0)

; 115  :         detune = 0.0f;
; 116  :     } else {

	jmp	SHORT $LN6@padFreq
$LN16@padFreq:

; 114  :     if( time < 0.0f ) {

	fstp	ST(2)

; 69   :     return a - b * floor_( a / b );

	fmulp	ST(1), ST(0)

; 41   :     return f2i( x - 0.5f );

	fsub	DWORD PTR __real@3f000000
	fstp	DWORD PTR _x$2[ebp]

; 117  :         time = mod( time, 12.0f );        

	fld	DWORD PTR _x$2[ebp]
	fistp	DWORD PTR _tmp$1[ebp]

; 41   :     return f2i( x - 0.5f );

	fild	DWORD PTR _tmp$1[ebp]

; 69   :     return a - b * floor_( a / b );

	fmul	DWORD PTR __real@41400000
	fsubr	DWORD PTR _time$[ebp]

; 118  :         if( time < 2.0f ) detune = 6.3f;

	fld	DWORD PTR __real@40000000
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@padFreq
	fstp	ST(0)
	fld	DWORD PTR __real@40c9999a
	jmp	SHORT $LN6@padFreq
$LN4@padFreq:

; 119  :         else if( time < 4.0f ) detune = 4.1f;

	fcomp	DWORD PTR __real@40800000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN14@padFreq
	fld	DWORD PTR __real@40833333
	jmp	SHORT $LN6@padFreq
$LN14@padFreq:
	fldz
$LN6@padFreq:

; 120  :     }    
; 121  :             
; 122  :     return 32.0f * pow_( 2.0f, detune / 12.0f );

	fmul	DWORD PTR __real@3daaaaab
	push	ecx
	push	ecx
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR __real@40000000
	fstp	DWORD PTR [esp]
	call	_pow_
	fmul	DWORD PTR __real@42000000
	add	esp, 8

; 123  : }

	leave
	ret	0
_padFreq ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\dev\raw4k\synth\synth.c
;	COMDAT _hat
_TEXT	SEGMENT
tv90 = -4						; size = 4
_time$ = 8						; size = 4
_hat	PROC						; COMDAT

; 107  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 108  :      return 0.33f * funcRand( 20000.0f * pow_( 2.72f, -10.0f*time )) * pow_( 2.72f, -30.0f*time );

	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR __real@c1200000
	push	ecx
	push	ecx
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR __real@402e147b
	fstp	DWORD PTR [esp]
	call	_pow_
	fmul	DWORD PTR __real@469c4000
	add	esp, 4
	fstp	DWORD PTR [esp]
	call	_funcRand
	fmul	DWORD PTR __real@3ea8f5c3
	fstp	DWORD PTR tv90[ebp]
	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR __real@c1f00000
	fstp	DWORD PTR [esp]
	fld	DWORD PTR __real@402e147b
	push	ecx
	fstp	DWORD PTR [esp]
	call	_pow_
	fmul	DWORD PTR tv90[ebp]
	add	esp, 8

; 109  : }

	leave
	ret	0
_hat	ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\dev\raw4k\synth\synth.c
;	COMDAT _kick
_TEXT	SEGMENT
tv143 = -12						; size = 8
tv145 = -4						; size = 4
_time$ = 8						; size = 4
_kick	PROC						; COMDAT

; 100  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 101  :     float attack = clamp( 400.0f*time, 0.0f, 1.0f );
; 102  :     float decay = 1. - smoothstep( 0.4f, 0.5f, time );
; 103  :     return attack * decay * sinf( 220.0f * pow_( time, 0.65f ));

	fld	DWORD PTR __real@3f266666
	push	ecx
	push	ecx
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _time$[ebp]
	fstp	DWORD PTR [esp]
	call	_pow_
	fmul	DWORD PTR __real@435c0000
	fsin
	fstp	QWORD PTR tv143[ebp]
	fld	DWORD PTR _time$[ebp]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR __real@3f000000
	fstp	DWORD PTR [esp]
	fld	DWORD PTR __real@3ecccccd
	push	ecx
	fstp	DWORD PTR [esp]
	call	_smoothstep
	fld1
	fld	ST(0)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR tv145[ebp]
	fstp	DWORD PTR [esp+8]
	fldz
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR __real@43c80000
	fstp	DWORD PTR [esp]
	call	_clamp
	fmul	DWORD PTR tv145[ebp]
	add	esp, 12					; 0000000cH
	fmul	QWORD PTR tv143[ebp]

; 104  : }

	leave
	ret	0
_kick	ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\dev\raw4k\synth\synth.c
;	COMDAT _taylorSquareWave
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_x$ = 8							; size = 4
_taylorSquareWave PROC					; COMDAT

; 87   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 88   :     float result = 0.0f;

	fldz
	xor	eax, eax
	fld	DWORD PTR _x$[ebp]
	inc	eax
	fld	DWORD PTR __real@3fa2f983
	mov	DWORD PTR _i$1[ebp], eax
$LN4@taylorSqua:

; 91   :     {
; 92   :         float n = (float)i;

	fild	DWORD PTR _i$1[ebp]
	add	eax, 2
	mov	DWORD PTR _i$1[ebp], eax

; 93   :         result += 4.0f / PI / n * sinf( n * x );

	fld	ST(0)
	fmul	ST(0), ST(3)
	fsin
	fld	ST(2)
	fdivrp	ST(2), ST(0)
	fmulp	ST(1), ST(0)
	faddp	ST(3), ST(0)
	cmp	eax, 5
	jle	SHORT $LN4@taylorSqua

; 89   :     
; 90   :     for( int i = 1; i <= 5; i += 2 )

	fstp	ST(1)
	fstp	ST(0)

; 94   :     } 
; 95   :     
; 96   :     return result;
; 97   : }

	leave
	ret	0
_taylorSquareWave ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\dev\raw4k\synth\synth.c
;	COMDAT _funcRand
_TEXT	SEGMENT
_a$1$ = -16						; size = 4
tv87 = -12						; size = 4
_x$1 = -12						; size = 4
_tmp$2 = -8						; size = 4
_x$ = -8						; size = 4
_tmp$3 = -8						; size = 4
_b$1$ = -4						; size = 4
_tmp$4 = -4						; size = 4
_x$ = -4						; size = 4
_x$ = 8							; size = 4
_funcRand PROC						; COMDAT

; 80   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 41   :     return f2i( x - 0.5f );

	fld	DWORD PTR _x$[ebp]
	fsub	DWORD PTR __real@3f000000
	fst	DWORD PTR tv87[ebp]
	fstp	DWORD PTR _x$[ebp]

; 81   :     float a = hash( floor_( x ));

	fld	DWORD PTR _x$[ebp]
	fistp	DWORD PTR _tmp$3[ebp]

; 41   :     return f2i( x - 0.5f );

	fild	DWORD PTR _tmp$3[ebp]

; 81   :     float a = hash( floor_( x ));

	push	ecx
	fstp	DWORD PTR [esp]
	call	_hash
	fstp	DWORD PTR _a$1$[ebp]

; 41   :     return f2i( x - 0.5f );

	fld	DWORD PTR _x$[ebp]

; 81   :     float a = hash( floor_( x ));

	add	esp, 4

; 41   :     return f2i( x - 0.5f );

	fadd	DWORD PTR __real@3f000000
	fstp	DWORD PTR _x$[ebp]

; 82   :     float b = hash( floor_( x + 1.0f ));

	fld	DWORD PTR _x$[ebp]
	fistp	DWORD PTR _tmp$4[ebp]

; 41   :     return f2i( x - 0.5f );

	fild	DWORD PTR _tmp$4[ebp]

; 82   :     float b = hash( floor_( x + 1.0f ));

	push	ecx
	fstp	DWORD PTR [esp]
	call	_hash
	fstp	DWORD PTR _b$1$[ebp]

; 41   :     return f2i( x - 0.5f );

	fld	DWORD PTR tv87[ebp]

; 82   :     float b = hash( floor_( x + 1.0f ));

	add	esp, 4

; 41   :     return f2i( x - 0.5f );

	fstp	DWORD PTR _x$1[ebp]

; 83   :     return 1.0f - 2.0f * mix( a, b, smoothstep( 0.0f, 1.0f, fract( x )));

	fld	DWORD PTR _x$1[ebp]
	fistp	DWORD PTR _tmp$2[ebp]

; 41   :     return f2i( x - 0.5f );

	fild	DWORD PTR _tmp$2[ebp]

; 83   :     return 1.0f - 2.0f * mix( a, b, smoothstep( 0.0f, 1.0f, fract( x )));

	sub	esp, 12					; 0000000cH

; 64   :     return a - floor_(a);

	fsubr	DWORD PTR _x$[ebp]

; 83   :     return 1.0f - 2.0f * mix( a, b, smoothstep( 0.0f, 1.0f, fract( x )));

	fstp	DWORD PTR [esp+8]
	fld1
	fstp	DWORD PTR [esp+4]
	fldz
	fstp	DWORD PTR [esp]
	call	_smoothstep

; 59   :     return a + t*(b - a);

	fld	DWORD PTR _b$1$[ebp]

; 83   :     return 1.0f - 2.0f * mix( a, b, smoothstep( 0.0f, 1.0f, fract( x )));

	add	esp, 12					; 0000000cH

; 59   :     return a + t*(b - a);

	fld	DWORD PTR _a$1$[ebp]
	fsub	ST(1), ST(0)
	fxch	ST(2)
	fmulp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fxch	ST(1)
	fadd	ST(0), ST(0)

; 83   :     return 1.0f - 2.0f * mix( a, b, smoothstep( 0.0f, 1.0f, fract( x )));

	faddp	ST(1), ST(0)
	fld1
	fsubrp	ST(1), ST(0)

; 84   : }

	leave
	ret	0
_funcRand ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\dev\raw4k\synth\synth.c
;	COMDAT _hash
_TEXT	SEGMENT
tv72 = -12						; size = 8
_tmp$1 = -4						; size = 4
_x$2 = 8						; size = 4
_i$ = 8							; size = 4
_hash	PROC						; COMDAT

; 75   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 76   :     return fract( sinf( i * 12.9898f ) * 43758.5453f );

	fld	DWORD PTR _i$[ebp]
	fmul	DWORD PTR __real@414fd639
	fsin
	fmul	QWORD PTR __real@40e55dd180000000
	fst	QWORD PTR tv72[ebp]

; 41   :     return f2i( x - 0.5f );

	fsub	DWORD PTR __real@3f000000
	fstp	DWORD PTR _x$2[ebp]

; 76   :     return fract( sinf( i * 12.9898f ) * 43758.5453f );

	fld	DWORD PTR _x$2[ebp]
	fistp	DWORD PTR _tmp$1[ebp]

; 41   :     return f2i( x - 0.5f );

	fild	DWORD PTR _tmp$1[ebp]

; 64   :     return a - floor_(a);

	fsubr	QWORD PTR tv72[ebp]

; 77   : }

	leave
	ret	0
_hash	ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\dev\raw4k\synth\synth.c
;	COMDAT _mod
_TEXT	SEGMENT
_tmp$1 = -8						; size = 4
_x$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_mod	PROC						; COMDAT

; 68   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ecx

; 69   :     return a - b * floor_( a / b );

	fld	DWORD PTR _a$[ebp]
	fdiv	DWORD PTR _b$[ebp]

; 41   :     return f2i( x - 0.5f );

	fsub	DWORD PTR __real@3f000000
	fstp	DWORD PTR _x$[ebp]

; 69   :     return a - b * floor_( a / b );

	fld	DWORD PTR _x$[ebp]
	fistp	DWORD PTR _tmp$1[ebp]

; 41   :     return f2i( x - 0.5f );

	fild	DWORD PTR _tmp$1[ebp]

; 69   :     return a - b * floor_( a / b );

	fmul	DWORD PTR _b$[ebp]
	fsubr	DWORD PTR _a$[ebp]

; 70   : }

	leave
	ret	0
_mod	ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\dev\raw4k\synth\synth.c
;	COMDAT _fract
_TEXT	SEGMENT
_tmp$1 = -8						; size = 4
_x$ = -4						; size = 4
_a$ = 8							; size = 4
_fract	PROC						; COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ecx

; 41   :     return f2i( x - 0.5f );

	fld	DWORD PTR _a$[ebp]
	fsub	DWORD PTR __real@3f000000
	fstp	DWORD PTR _x$[ebp]

; 64   :     return a - floor_(a);

	fld	DWORD PTR _x$[ebp]
	fistp	DWORD PTR _tmp$1[ebp]

; 41   :     return f2i( x - 0.5f );

	fild	DWORD PTR _tmp$1[ebp]

; 64   :     return a - floor_(a);

	fsubr	DWORD PTR _a$[ebp]

; 65   : }

	leave
	ret	0
_fract	ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\dev\raw4k\synth\synth.c
;	COMDAT _mix
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_t$ = 16						; size = 4
_mix	PROC						; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :     return a + t*(b - a);

	fld	DWORD PTR _b$[ebp]
	fld	DWORD PTR _a$[ebp]
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fmul	DWORD PTR _t$[ebp]
	faddp	ST(1), ST(0)

; 60   : }

	pop	ebp
	ret	0
_mix	ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\dev\raw4k\synth\synth.c
;	COMDAT _smoothstep
_TEXT	SEGMENT
_edge0$ = 8						; size = 4
_edge1$ = 12						; size = 4
_x$ = 16						; size = 4
_smoothstep PROC					; COMDAT

; 52   : {

	push	ebp
	mov	ebp, esp

; 53   :     x = clamp((x - edge0) / (edge1 - edge0), 0.0f, 1.0f); 

	fld1
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	fldz
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _x$[ebp]
	fld	DWORD PTR _edge0$[ebp]
	fsub	ST(1), ST(0)
	fsubr	DWORD PTR _edge1$[ebp]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR [esp]
	call	_clamp

; 54   :     return x * x * (3 - 2 * x);

	fld	ST(0)
	add	esp, 12					; 0000000cH
	fadd	ST(0), ST(1)
	fsubr	DWORD PTR __real@40400000
	fxch	ST(1)
	fmul	ST(0), ST(0)
	fmulp	ST(1), ST(0)

; 55   : }

	pop	ebp
	ret	0
_smoothstep ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\dev\raw4k\synth\synth.c
;	COMDAT _clamp
_TEXT	SEGMENT
_x$ = 8							; size = 4
_lowerlimit$ = 12					; size = 4
_upperlimit$ = 16					; size = 4
_clamp	PROC						; COMDAT

; 45   : {

	push	ebp
	mov	ebp, esp

; 46   :     if (x < lowerlimit) x = lowerlimit;

	fld	DWORD PTR _lowerlimit$[ebp]
	fld	DWORD PTR _x$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN6@clamp
	fstp	ST(0)
	jmp	SHORT $LN2@clamp
$LN6@clamp:
	fstp	ST(1)
$LN2@clamp:

; 47   :     if (x > upperlimit) x = upperlimit;

	fld	DWORD PTR _upperlimit$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN9@clamp
	fstp	ST(1)

; 48   :     return x;
; 49   : }

	pop	ebp
	ret	0
$LN9@clamp:

; 47   :     if (x > upperlimit) x = upperlimit;

	fstp	ST(0)

; 48   :     return x;
; 49   : }

	pop	ebp
	ret	0
_clamp	ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\dev\raw4k\synth\synth.c
;	COMDAT _floor_
_TEXT	SEGMENT
_tmp$1 = -4						; size = 4
_x$ = 8							; size = 4
_x$ = 8							; size = 4
_floor_	PROC						; COMDAT

; 40   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 41   :     return f2i( x - 0.5f );

	fld	DWORD PTR _x$[ebp]
	fsub	DWORD PTR __real@3f000000
	fstp	DWORD PTR _x$[ebp]
	fld	DWORD PTR _x$[ebp]
	fistp	DWORD PTR _tmp$1[ebp]
	fild	DWORD PTR _tmp$1[ebp]

; 42   : }

	leave
	ret	0
_floor_	ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\dev\raw4k\synth\synth.c
;	COMDAT _pow_
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_pow_	PROC						; COMDAT

; 19   : {

	push	ebp
	mov	ebp, esp

; 20   :     _asm {
; 21   :         fld dword ptr[b]

	fld	DWORD PTR _b$[ebp]

; 22   :         fld dword ptr[a]

	fld	DWORD PTR _a$[ebp]

; 23   :         fyl2x

	fyl2x

; 24   :         fist dword ptr[b]

	fist	DWORD PTR _b$[ebp]

; 25   :         fild dword ptr[b]

	fild	DWORD PTR _b$[ebp]

; 26   :         fsub

	fsubp	ST(1), ST(0)

; 27   :         f2xm1

	f2xm1

; 28   :         fld1

	fld1

; 29   :         fadd

	faddp	ST(1), ST(0)

; 30   :         fild dword ptr[b]

	fild	DWORD PTR _b$[ebp]

; 31   :         fxch

	fxch	ST(1)

; 32   :         fscale

	fscale

; 33   :         fstp dword ptr[a]

	fstp	DWORD PTR _a$[ebp]

; 34   :         fstp dword ptr[b]

	fstp	DWORD PTR _b$[ebp]

; 35   :         fld dword ptr[a]

	fld	DWORD PTR _a$[ebp]

; 36   :     }
; 37   : }

	pop	ebp
	ret	0
_pow_	ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\dev\raw4k\synth\synth.c
;	COMDAT _f2i
_TEXT	SEGMENT
_tmp$ = -4						; size = 4
_x$ = 8							; size = 4
_f2i	PROC						; COMDAT

; 9    : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10   :     int tmp;
; 11   :     _asm {
; 12   :         fld dword ptr[x]

	fld	DWORD PTR _x$[ebp]

; 13   :         fistp dword ptr[tmp];

	fistp	DWORD PTR _tmp$[ebp]

; 14   :     }
; 15   :     return tmp;

	mov	eax, DWORD PTR _tmp$[ebp]

; 16   : }

	leave
	ret	0
_f2i	ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File d:\dev\raw4k\synth\synth.c
;	COMDAT _runSynth@4
_TEXT	SEGMENT
_tmp$1 = -12						; size = 4
_tmp$2 = -8						; size = 4
tv197 = -4						; size = 4
_i$3 = -4						; size = 4
_x$ = 8							; size = 4
_x$ = 8							; size = 4
_buffer$ = 8						; size = 4
_runSynth@4 PROC					; COMDAT

; 155  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 156  :     for( int i = 0; i < AUDIO_NUMSAMPLES; i++ ) 

	mov	edx, DWORD PTR _buffer$[ebp]
	xor	ecx, ecx
	fld	DWORD PTR __real@37be37c6
	mov	DWORD PTR _i$3[ebp], ecx
$LN4@runSynth:

; 157  :     {
; 158  :         const float amplitude = getSound( (float)i/(float)AUDIO_RATE );

	fimul	DWORD PTR _i$3[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	_getSound

; 159  :         buffer[2*i+0] = f2i(amplitude*32767.0f);

	fmul	DWORD PTR __real@46fffe00
	add	esp, 4
	fst	DWORD PTR tv197[ebp]
	fstp	DWORD PTR _x$[ebp]
	fld	DWORD PTR _x$[ebp]
	fistp	DWORD PTR _tmp$2[ebp]
	mov	ax, WORD PTR _tmp$2[ebp]

; 160  :         buffer[2*i+1] = f2i(amplitude*32767.0f);

	fld	DWORD PTR tv197[ebp]
	fstp	DWORD PTR _x$[ebp]
	mov	WORD PTR [edx+ecx*4], ax
	fld	DWORD PTR _x$[ebp]
	fistp	DWORD PTR _tmp$1[ebp]
	mov	ax, WORD PTR _tmp$1[ebp]
	fld	DWORD PTR __real@37be37c6
	mov	WORD PTR [edx+ecx*4+2], ax
	inc	ecx
	mov	DWORD PTR _i$3[ebp], ecx
	cmp	ecx, 4410000				; 00434a90H
	jl	SHORT $LN4@runSynth

; 156  :     for( int i = 0; i < AUDIO_NUMSAMPLES; i++ ) 

	fstp	ST(0)

; 161  :     }
; 162  : }

	leave
	ret	4
_runSynth@4 ENDP
_TEXT	ENDS
END
